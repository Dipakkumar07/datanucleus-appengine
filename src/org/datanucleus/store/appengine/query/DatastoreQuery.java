// Copyright 2008 Google Inc. All Rights Reserved.
package org.datanucleus.store.appengine.query;

import com.google.apphosting.api.datastore.DatastoreService;
import com.google.apphosting.api.datastore.Entity;
import com.google.apphosting.api.datastore.Query;
import com.google.common.base.Function;
import com.google.common.collect.ImmutableMapBuilder;
import com.google.common.collect.Sets;

import org.datanucleus.ClassLoaderResolver;
import org.datanucleus.FetchPlan;
import org.datanucleus.ManagedConnection;
import org.datanucleus.ObjectManager;
import org.datanucleus.StateManager;
import org.datanucleus.metadata.AbstractClassMetaData;
import org.datanucleus.query.compiler.QueryCompilation;
import org.datanucleus.query.expression.DyadicExpression;
import org.datanucleus.query.expression.Expression;
import org.datanucleus.query.expression.Literal;
import org.datanucleus.query.expression.OrderExpression;
import org.datanucleus.query.expression.PrimaryExpression;
import org.datanucleus.store.FieldValues;
import org.datanucleus.store.appengine.DatastoreFieldManager;
import org.datanucleus.store.query.AbstractJavaQuery;
import org.datanucleus.util.Localiser;
import org.datanucleus.util.NucleusLogger;

import java.io.Serializable;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A unified JDOQL/JPQL query implementation for Datastore.
 *
 * Datanucleus supports in-memory evaluation of queries, but
 * for now we have it disabled and are only allowing queries
 * that can be natively fulfilled by the app engine datastore.
 *
 * TODO(maxr): More logging
 * TODO(maxr): Localized logging
 * TODO(maxr): Localized exception messages.
 *
 * @author Erick Armbrust <earmbrust@google.com>
 * @author Max Ross <maxr@google.com>
 */
public class DatastoreQuery implements Serializable {

  // Exposed for testing
  static final Expression.Operator GROUP_BY_OP = new Expression.Operator(
      "GROUP BY", Integer.MAX_VALUE);

  // Exposed for testing
  static final Expression.Operator HAVING_OP = new Expression.Operator(
      "HAVING", Integer.MAX_VALUE);

  static final Set<Expression.Operator> UNSUPPORTED_OPERATORS = Sets
      .newHashSet((Expression.Operator) Expression.OP_ADD,
          (Expression.Operator) Expression.OP_BETWEEN,
          (Expression.Operator) Expression.OP_COM,
          (Expression.Operator) Expression.OP_CONCAT,
          (Expression.Operator) Expression.OP_DIV,
          (Expression.Operator) Expression.OP_IS,
          (Expression.Operator) Expression.OP_ISNOT,
          (Expression.Operator) Expression.OP_LIKE,
          (Expression.Operator) Expression.OP_MOD,
          (Expression.Operator) Expression.OP_NEG,
          (Expression.Operator) Expression.OP_MUL,
          (Expression.Operator) Expression.OP_NOT,
          (Expression.Operator) Expression.OP_OR,
          (Expression.Operator) Expression.OP_SUB);

  private static final Map<Expression.Operator, Query.FilterOperator> DATANUCLEUS_OP_TO_APPENGINE_OP =
      new ImmutableMapBuilder<Expression.Operator, Query.FilterOperator>()
          .put(Expression.OP_EQ, Query.FilterOperator.EQUAL)
          .put(Expression.OP_GT, Query.FilterOperator.GREATER_THAN)
          .put(Expression.OP_GTEQ, Query.FilterOperator.GREATER_THAN_OR_EQUAL)
          .put(Expression.OP_LT, Query.FilterOperator.LESS_THAN)
          .put(Expression.OP_LTEQ, Query.FilterOperator.LESS_THAN_OR_EQUAL)
          .getMap();

  /**
   * The query that is generated by Datanucleus.
   */
  private final AbstractJavaQuery query;

  /**
   * The datastore query that we most recently executed.
   * This should only be used for testing.
   */
  private transient Query mostRecentDatastoreQuery;

  /**
   * Constructs a new Datastore query based on a Datanucleus query.
   *
   * @param query The Datanucleus query to be translated into a Datastore query.
   */
  public DatastoreQuery(AbstractJavaQuery query) {
    this.query = query;
  }

  /**
   * We'd like to return {@link Iterable} instead but
   * {@link javax.persistence.Query#getResultList()} returns {@link List}.
   */
  public List<?> performExecute(Localiser localiser, QueryCompilation compilation, Map parameters) {
    validate();

    ObjectManager om = query.getObjectManager();
    long startTime = System.currentTimeMillis();
    if (NucleusLogger.QUERY.isDebugEnabled()) {
      NucleusLogger.QUERY.debug(localiser.msg("021046", "DATASTORE", query.getSingleStringQuery(), null));
    }
    ManagedConnection mconn = om.getStoreManager().getConnection(om);
    try {
      DatastoreService ds = (DatastoreService) mconn.getConnection();
      // TODO(maxr): Don't force users to use fqn as the kind.
      String candidateClassName = query.getCandidateClass().getName();
      mostRecentDatastoreQuery = new Query(candidateClassName);
      addFilters(compilation, mostRecentDatastoreQuery, parameters);
      addSorts(compilation, mostRecentDatastoreQuery);
      Iterable<Entity> entities = ds.prepare(mostRecentDatastoreQuery).asIterable();
      if (NucleusLogger.QUERY.isDebugEnabled()) {
        NucleusLogger.QUERY.debug(localiser.msg("021074", "DATASTORE",
            "" + (System.currentTimeMillis() - startTime)));
      }
      final ClassLoaderResolver clr = om.getClassLoaderResolver();
      final AbstractClassMetaData acmd =
          om.getMetaDataManager().getMetaDataForClass(query.getCandidateClass(), clr);

      Function<Entity, Object> entityToPojoFunc = new Function<Entity, Object>() {
        public Object apply(Entity entity) {
          return entityToPojo(entity, acmd, clr);
        }
      };
      return new StreamingQueryResult(query, entities, entityToPojoFunc);
    } finally {
      mconn.release();
    }
  }

  private Object entityToPojo(final Entity entity, final AbstractClassMetaData acmd,
      final ClassLoaderResolver clr) {
    FieldValues fv = new FieldValues() {
      public void fetchFields(StateManager sm) {
        sm.replaceFields(acmd.getAllMemberPositions(), new DatastoreFieldManager(sm, entity));
      }
      public void fetchNonLoadedFields(StateManager sm) {
        sm.replaceNonLoadedFields(
            acmd.getAllMemberPositions(), new DatastoreFieldManager(sm, entity));
      }
      public FetchPlan getFetchPlanForLoading() {
        return null;
      }
    };
    return query.getObjectManager().findObjectUsingAID(
        clr.classForName(acmd.getFullClassName()), fv, query.getIgnoreCache(), true);
  }

  private void validate() {
    // We don't support in-memory query fulfillment, so if the query contains
    // a grouping or a having it's automatically an error.
    if (query.getGrouping() != null) {
      throw new UnsupportedDatastoreOperatorException(query.getSingleStringQuery(),
          GROUP_BY_OP);
    }

    if (query.getHaving() != null) {
      throw new UnsupportedDatastoreOperatorException(query.getSingleStringQuery(),
          HAVING_OP);
    }
  }

  /**
   * Adds sorts to the given {@link Query} by examining the compiled order
   * expression.
   */
  private void addSorts(QueryCompilation compilation, Query q) {
    // Just parse by hand for now
    Expression[] orderBys = compilation.getExprOrdering();
    if (orderBys == null) {
      return;
    }
    for (Expression expr : orderBys) {
      OrderExpression oe = (OrderExpression) expr;
      Query.SortDirection dir = oe.getSortOrder().equals("ascending") ? Query.SortDirection.ASCENDING
          : Query.SortDirection.DESCENDING;
      String sortProp = ((PrimaryExpression) oe.getLeft()).getId();
      q.addSort(sortProp, dir);
    }
  }

  /**
   * Adds filters to the given {@link Query} by examining the compiled filter
   * expression.
   */
  private void addFilters(QueryCompilation compilation, Query q, Map parameters) {
    // Just parse by hand for now
    Expression filter = compilation.getExprFilter();
    addExpression(filter, q, parameters);
  }

  /**
   * Recursively walks the given expression, adding filters to the given
   * {@link Query} where appropriate.
   *
   * @throws UnsupportedDatastoreOperatorException If we encounter an operator
   *           that we don't support.
   * @throws UnsupportedDatastoreFeatureException If the query uses a feature
   *           that we don't support.
   */
  private void addExpression(Expression expr, Query q, Map parameters) {
    if (expr == null) {
      return;
    }
    checkForUnsupportedOperator(expr.getOperator());
    if (expr instanceof DyadicExpression) {
      if (expr.getOperator().equals(Expression.OP_AND)) {
        addExpression(expr.getLeft(), q, parameters);
        addExpression(expr.getRight(), q, parameters);
      } else if (DATANUCLEUS_OP_TO_APPENGINE_OP.get(expr.getOperator()) == null) {
        throw new UnsupportedDatastoreOperatorException(query.getSingleStringQuery(),
            expr.getOperator());
      } else if (expr.getLeft() instanceof PrimaryExpression) {
        addLeftPrimaryExpression((PrimaryExpression) expr.getLeft(), expr
            .getOperator(), expr.getRight(), q, parameters);
      } else {
        // Recurse!
        addExpression(expr.getLeft(), q, parameters);
        addExpression(expr.getRight(), q, parameters);
      }
    } else if (expr instanceof PrimaryExpression) {
      // Recurse!
      addExpression(expr.getLeft(), q, parameters);
      addExpression(expr.getRight(), q, parameters);
    } else {
      throw new UnsupportedDatastoreFeatureException(
          "Unexpected expression type while parsing " + query.getSingleStringQuery()
              + ": " + expr.getClass().getName());
    }
  }

  private void addLeftPrimaryExpression(PrimaryExpression left,
      Expression.Operator operator, Expression right, Query q, Map parameters) {
    String propName = left.getId();
    Query.FilterOperator op = DATANUCLEUS_OP_TO_APPENGINE_OP.get(operator);
    Object value;
    if (right instanceof PrimaryExpression) {
      value = parameters.get(((PrimaryExpression) right).getId());
    } else if (right instanceof Literal) {
      value = ((Literal) right).getLiteral();
    } else {
      // We hit an operator that is not in the unsupported list and does
      // not have an entry in DATANUCLEUS_OP_TO_APPENGINE_OP. Almost certainly
      // a programming error.
      throw new UnsupportedDatastoreFeatureException(query.getSingleStringQuery());
    }
    q.addFilter(propName, op, value);
  }

  private void checkForUnsupportedOperator(Expression.Operator operator) {
    if (UNSUPPORTED_OPERATORS.contains(operator)) {
      throw new UnsupportedDatastoreOperatorException(query.getSingleStringQuery(),
          operator);
    }
  }

  // Exposed for tests
  Query getMostRecentDatastoreQuery() {
    return mostRecentDatastoreQuery;
  }

  // Specialization just exists to support tests
  static class UnsupportedDatastoreOperatorException extends
      UnsupportedOperationException {
    private final String queryString;
    private final Expression.Operator operator;

    UnsupportedDatastoreOperatorException(String queryString,
        Expression.Operator operator) {
      super(queryString);
      this.queryString = queryString;
      this.operator = operator;
    }

    @Override
    public String getMessage() {
      return "Problem with query <" + queryString
          + ">: App Engine datastore does not support operator " + operator;
    }

    public Expression.Operator getOperation() {
      return operator;
    }
  }

  // Specialization just exists to support tests
  static class UnsupportedDatastoreFeatureException extends
      UnsupportedOperationException {
    private final String queryString;

    UnsupportedDatastoreFeatureException(String queryString) {
      super(queryString);
      this.queryString = queryString;
    }

    @Override
    public String getMessage() {
      return "Problem with query <"
          + queryString
          + ">: App Engine datastore does not support one or more features of this query.";
    }
  }
}
